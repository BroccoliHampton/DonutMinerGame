<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pinky Glazers ツ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* [KEEPING ALL THE ORIGINAL STYLES - NO CHANGES] */
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap');
        
        body {
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overscroll-behavior: none;
            background-color: #FFC0CB;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cg opacity='0.7'%3E%3Crect x='10' y='10' width='3' height='10' fill='%23FFD700' transform='rotate(25 11.5 15)' /%3E%3Crect x='60' y='30' width='3' height='10' fill='%23FF69B4' transform='rotate(140 61.5 35)' /%3E%3Crect x='30' y='70' width='3' height='10' fill='%2390EE90' transform='rotate(70 31.5 75)' /%3E%3Crect x='80' y='85' width='3' height='10' fill='%2387CEEB' transform='rotate(210 81.5 90)' /%3E%3Crect x='5' y='45' width='3' height='10' fill='%23FFD700' transform='rotate(100 6.5 50)' /%3E%3Crect x='90' y='5' width='3' height='10' fill='%23FF69B4' transform='rotate(300 91.5 10)' /%3E%3C/g%3E%3C/svg%3E"), 
                            linear-gradient(135deg, #FFC0CB 0%, #FFDDE1 100%);
            background-size: 200px 200px, cover;
            background-blend-mode: overlay, normal;
            background-attachment: fixed;
            color: #333333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 0;
            margin: 0;
        }

        .bg-tamagotchi-bg-light { background-color: #FFFACD; } 
        .text-tamagotchi-dark { color: #333333; }
        .text-tamagotchi-pink-dark { color: #E75480; }
        .text-tamagotchi-pink-light { color: #FF9AA2; }
        
        .bg-tamagotchi-button-pink { 
            background: linear-gradient(to bottom, #FFDDE1, #E75480);
            color: white;
            font-weight: 800;
            border: 2px solid #C04A70;
        }
        .bg-tamagotchi-button-teal { 
            background: linear-gradient(to bottom, #B3F0E6, #66CCBF);
            color: white;
            font-weight: 800;
            border: 2px solid #50A89C;
        }
        .bg-tamagotchi-button-pink:active, .bg-tamagotchi-button-teal:active {
            transform: translateY(1px);
            box-shadow: none;
        }

        .border-tamagotchi-subtle { border-color: #E0E0E0; }
        .bg-tamagotchi-card { 
            background-color: #FFFACD;
            border: 2px solid #E0E0E0;
        }
        .border-tamagotchi-accent-pink { border-color: #FF9AA2; }

        .rounded-tamagotchi-lg { border-radius: 20px; }
        .rounded-tamagotchi-md { border-radius: 14px; }
        .rounded-tamagotchi-full { border-radius: 9999px; }

        .shadow-tamagotchi { box-shadow: 0px 6px 15px rgba(0, 0, 0, 0.1); }
        
        .nav-icon span {
            font-size: 32px;
            color: #A0A0A0;
            transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .nav-icon.active span {
            color: #E75480;
            transform: scale(1.1);
        }

        #cookie-canvas {
            width: 100%;
            height: 100%;
            max-width: 400px;
            max-height: 400px;
            cursor: grab;
            touch-action: none;
            position: relative;
            z-index: 20;
            margin: auto;
        }
        #cookie-canvas:active {
            cursor: grabbing;
        }

        .color-cycle-button {
            position: absolute;
            bottom: 10px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #E0E0E0;
            background-color: #f0f0f0;
            box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s ease-in-out, background-color 0.2s;
            z-index: 30;
        }
        .color-cycle-button:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        #glaze-color-button {
            right: 8px;
        }
        #sprinkle-color-button {
            right: 48px;
        }
        #donut-base-color-button {
            right: 88px;
        }

        .glitch-static {
            position: relative;
            overflow: hidden;
            background-color: #FFFACD !important;
        }

        .glitch-static::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(240, 230, 200, 0.4) 1px, transparent 1px),
                linear-gradient(90deg, rgba(240, 230, 200, 0.4) 1px, transparent 1px);
            background-size: 4px 4px;
            animation: static-flicker 0.5s infinite alternate, static-move 3s steps(10) infinite;
            opacity: 0.6;
            pointer-events: none;
            z-index: 15;
        }

        .glitch-static::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(240, 230, 200, 0.2) 50%,
                transparent 100%
            );
            mix-blend-mode: overlay;
            animation: scanline 8s linear infinite;
            opacity: 0.3;
            pointer-events: none;
            z-index: 16;
        }

        @keyframes static-flicker {
            0% { background-position: 0 0; opacity: 0.6; }
            50% { background-position: 8px 8px; opacity: 0.5; }
            100% { background-position: 0 0; opacity: 0.7; }
        }

        @keyframes static-move {
            0% { transform: translate(0, 0); }
            100% { transform: translate(0, 100%); }
        }

        @keyframes scanline {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        .falling-snow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 17;
            overflow: hidden;
        }

        .falling-snow::before,
        .falling-snow::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 10% 20%, #A0A0A0 1px, transparent 1px),
                radial-gradient(circle at 70% 80%, #C0C0C0 1px, transparent 1px),
                radial-gradient(circle at 30% 60%, #B0B0B0 1px, transparent 1px),
                radial-gradient(circle at 90% 10%, #E0E0E0 1px, transparent 1px),
                radial-gradient(circle at 50% 40%, #D0D0D0 1px, transparent 1px),
                radial-gradient(circle at 20% 90%, #F0F0F0 1px, transparent 1px),
                radial-gradient(circle at 80% 30%, #A0A0A0 1px, transparent 1px),
                radial-gradient(circle at 40% 70%, #C0C0C0 1px, transparent 1px),
                radial-gradient(circle at 60% 5%, #B0B0B0 1px, transparent 1px),
                radial-gradient(circle at 5% 50%, #E0E0E0 1px, transparent 1px),
                radial-gradient(circle at 95% 45%, #D0D0D0 1px, transparent 1px);
            background-repeat: repeat;
            background-size: 20px 20px;
            animation: snowfall 10s linear infinite;
            opacity: 0.7;
        }

        .falling-snow::after {
            animation-delay: 5s;
            background-size: 25px 25px;
            opacity: 0.6;
            filter: blur(0.5px);
        }

        @keyframes snowfall {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        .ticker-wrap {
            width: 100%;
            overflow: hidden;
            background-color: #333;
            padding: 4px 0;
            border-top: 2px solid #555;
            border-bottom: 2px solid #555;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        #top-ticker { margin-bottom: 8px; }
        #bottom-ticker { margin-top: 8px; }

        .ticker-move {
            display: inline-block;
            white-space: nowrap;
            animation: scroll-ticker 20s linear infinite;
            color: #FFFACD;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Comic Neue', cursive;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        .ticker-move-reverse {
            display: inline-block;
            white-space: nowrap;
            animation: scroll-ticker-reverse 20s linear infinite;
            color: #FFFACD;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Comic Neue', cursive;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        @keyframes scroll-ticker {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-50%); }
        }

        @keyframes scroll-ticker-reverse {
            0% { transform: translateX(-50%); }
            100% { transform: translateX(0%); }
        }
        
        body.dark {
            background-color: #5C3317;
            background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%236B4A34' fill-opacity='0.4'%3E%3Cpath d='M10 0L0 10l10 10 10-10z'/%3E%3Cpath d='M0 10L10 20l10-10L10 0z'/%3E%3C/g%3E%3C/svg%3E"), 
                            linear-gradient(135deg, #5C3317 0%, #3D2B1F 100%);
        }

        body.dark .bg-tamagotchi-card {
            background-color: #3D2B1F;
            border-color: #4A3A2A;
        }
        
        body.dark .text-tamagotchi-dark { color: #F5E6C1; }
        body.dark .text-gray-500 { color: #A8998A; }
        body.dark .text-gray-600 { color: #B8A99A; }
        
        body.dark .text-tamagotchi-pink-dark { color: #FF9AA2; }

        body.dark .glitch-static {
            background-color: #3D2B1F !important;
        }
        body.dark .glitch-static::before {
            background: 
                linear-gradient(rgba(150, 130, 110, 0.4) 1px, transparent 1px),
                linear-gradient(90deg, rgba(150, 130, 110, 0.4) 1px, transparent 1px);
        }
        body.dark .glitch-static::after {
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(150, 130, 110, 0.2) 50%,
                transparent 100%
            );
        }
        
        body.dark .falling-snow::before {
            opacity: 0.4;
        }
        body.dark .falling-snow::after {
            opacity: 0.3;
        }

        body.dark .border-tamagotchi-subtle { border-color: #4A3A2A; }
        
        body.dark .nav-icon span {
            color: #A8998A;
        }
        body.dark .nav-icon.active span {
            color: #FF9AA2;
        }
        
        body.dark .color-cycle-button {
            background-color: #3D2B1F;
            border-color: #4A3A2A;
            color: #F5E6C1;
        }
        
        body.dark .bg-tamagotchi-bg-light {
            background-color: #3D2B1F;
        }

        .zoom-slider {
            position: absolute;
            top: 50%;
            right: 8px;
            transform: translateY(-50%);
            width: 16px;
            height: 100px;
            -webkit-appearance: none;
            appearance: none;
            writing-mode: vertical-lr;
            direction: ltr;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            z-index: 30;
            padding: 0;
            transition: background 0.2s;
        }
        body.dark .zoom-slider {
            background: rgba(255, 255, 255, 0.2);
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #FFFACD;
            border-radius: 50%;
            border: 2px solid #E75480;
            cursor: grab;
        }
        .zoom-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #FFFACD;
            border-radius: 50%;
            border: 2px solid #E75480;
            cursor: grab;
        }
        body.dark .zoom-slider::-webkit-slider-thumb {
            background: #3D2B1F;
            border-color: #FF9AA2;
        }
        body.dark .zoom-slider::-moz-range-thumb {
            background: #3D2B1F;
            border-color: #FF9AA2;
        }
    </style>
</head>
<body class="text-tamagotchi-dark">
        
    <main class="flex-grow flex flex-col px-3 pt-4 pb-1 overflow-y-auto max-w-lg mx-auto w-full">
        <div class="flex justify-between items-center mb-2">
            <div class="flex flex-col">
                <h1 class="text-3xl font-black text-tamagotchi-pink-dark" style="font-family: 'Luckiest Guy', cursive;">Pinky Glazers</h1>
                
                <div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 flex items-center space-x-3 mt-1">
                    <div>
                        <div id="player-profile-name" class="font-extrabold text-sm truncate text-tamagotchi-dark">Loading...</div>
                    </div>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-1 self-start">
                <button id="dark-mode-toggle-button" class="bg-tamagotchi-button-teal text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80">🌙
                </button>
                <button id="info-button" class="bg-tamagotchi-button-pink text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80">❓
                </button>
                <button id="music-toggle-button" class="bg-tamagotchi-button-pink text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80">🔇
                </button>
                <button id="sfx-toggle-button" class="bg-tamagotchi-button-teal text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80">🔊
                </button>
            </div>
        </div>

        <div id="view-glazery" class="flex-grow flex flex-col">
            <div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 grid grid-cols-3 gap-2">
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">King Glazer</div>
                    <div id="bakery-king-status" class="font-extrabold text-sm truncate text-tamagotchi-dark">Loading...</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Glazed</div>
                    <div class="font-extrabold text-sm text-tamagotchi-dark">🍩 <span id="bakery-cps">0.00</span></div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Glaze Time</div>
                    <div class="font-extrabold text-sm text-tamagotchi-dark"><span id="bakery-baked">00:00:00</span></div>
                </div>
            </div>

            <div id="top-ticker" class="ticker-wrap" style="margin-bottom: 4px; margin-top: 8px;">
                <div class="ticker-move">
                    <span>Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... </span>
                </div>
            </div>

            <div id="cookie-rain-container" class="relative h-64 flex items-center justify-center overflow-hidden bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi glitch-static">
                <div class="falling-snow"></div>
                <canvas id="cookie-canvas"></canvas>
                <button id="glaze-color-button" class="color-cycle-button shadow-tamagotchi bg-white text-tamagotchi-dark">🎨</button>
                <button id="sprinkle-color-button" class="color-cycle-button shadow-tamagotchi bg-white text-tamagotchi-dark">🌈</button>
                <button id="donut-base-color-button" class="color-cycle-button shadow-tamagotchi bg-white text-tamagotchi-dark">🍩</button>
                <input id="glazery-zoom-slider" type="range" class="zoom-slider">
            </div>

            <div id="bottom-ticker" class="ticker-wrap" style="margin-top: 4px;">
                <div class="ticker-move-reverse">
                    <span>Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... </span>
                </div>
            </div>
            
            <div class="bg-tamagotchi-card text-tamagotchi-dark p-2 rounded-tamagotchi-lg shadow-tamagotchi">
                <div class="flex justify-between items-center">
                    <div>
                        <div class="text-xs font-semibold text-gray-600">Glaze Price</div>
                        <div id="glaze-price-display" class="text-xl font-extrabold text-tamagotchi-dark">$0.00</div>
                        <div id="available-balance-display" class="text-xs text-gray-500">$0.00 available</div>
                    </div>
                    <button id="bakery-action-button" class="bg-tamagotchi-button-pink text-white py-2 px-6 rounded-tamagotchi-md text-sm font-bold active:opacity-80 disabled:opacity-50 shadow-tamagotchi">
                        Glaze
                    </button>
                </div>
            </div>

            <div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 grid grid-cols-3 gap-2 mt-2">
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Donut Balance</div>
                    <div id="player-donut-balance" class="font-extrabold text-sm truncate text-tamagotchi-dark">🍩 0</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Total Supply</div>
                    <div id="total-supply-display" class="font-extrabold text-sm text-tamagotchi-dark">🍩 0</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">DPS</div>
                    <div id="current-dps-display" class="font-extrabold text-sm text-tamagotchi-dark">0</div>
                </div>
            </div>

        </div>
    </main>

    <div id="info-modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden"></div>
    <div id="info-modal" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 z-50 hidden w-11/12 max-w-xs text-tamagotchi-dark overflow-y-auto" style="max-height: 90vh;">
        <div class="flex justify-between items-center mb-2">
            <h3 class="text-xl font-bold text-tamagotchi-pink-dark">Info</h3>
            <button id="info-modal-close" class="text-2xl font-bold text-gray-500 hover:text-tamagotchi-pink-dark">&times;</button>
        </div>
        <div class="space-y-3">
            <div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 space-y-4 text-tamagotchi-dark">
                <p class="font-bold text-lg" style="font-family: 'Comic Neue', cursive;">
                    Hello and welcome to Pinky Glazers!
                </p>
                <p class="text-sm">
                    Pay the Glaze Price to become <strong>King Glazer</strong> and earn <strong>100%</strong> of the $DONUT emissions until you are replaced.
                </p>
                <p class="text-sm">
                    Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour.
                </p>
            </div>
            <h3 class="text-xl font-bold text-tamagotchi-pink-dark pt-2">Global Donut Stats</h3>
            <div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 space-y-3 text-tamagotchi-dark">
                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Total Donut Supply</span>
                    <span id="modal-total-supply" class="font-extrabold text-tamagotchi-dark">🍩 0</span>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Time Until Halving</span>
                    <span id="modal-next-halving" class="font-extrabold text-tamagotchi-dark">--:--:--</span>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Current Miner</span>
                    <span id="modal-current-miner" class="font-extrabold text-tamagotchi-dark text-xs">None</span>
                </div>
            </div>
        </div>
    </div>

<script>
        // =================================================================
        // BLOCKCHAIN CONFIGURATION
        // =================================================================
        // =================================================================
        // CONFIGURATION
        // =================================================================
        const API_BASE_URL = 'https://last-game-kappa.vercel.app';
        const REFRESH_INTERVAL = 10000; // 10 seconds

        // =================================================================
        // BLOCKCHAIN STATE  
        // =================================================================
        let blockchainData = {
            currentMiner: null,
            price: '0',
            priceInEth: '0.0',
            currentDps: '0',
            currentDpsFormatted: '0',
            userDonutBalance: '0',
            userDonutBalanceFormatted: '0',
            userEthBalance: '0',
            userEthBalanceFormatted: '0',
            claimableDonuts: '0',
            claimableDonutsFormatted: '0',
            totalDonutSupply: '0',
            totalDonutSupplyFormatted: '0',
            timeAsMiner: 0,
            secondsUntilHalving: 0,
            userAddress: null,
            fid: null
        };

        // =================================================================
        // FARCASTER SDK INITIALIZATION (FIX 1: EARLY STARTUP)
        // =================================================================
        let FarcasterSDK;

        async function initSDK() {
            try {
                const { default: sdk } = await import('https://esm.sh/@farcaster/miniapp-sdk');
                FarcasterSDK = sdk;
                // CRITICAL: Call ready() immediately to clear the splash screen
                await FarcasterSDK.actions.ready();
                console.log('[SDK] Farcaster SDK initialized and ready.');
            } catch (e) {
                console.error('[SDK] Failed to initialize Farcaster SDK:', e.message);
            }
        }
        
        // =================================================================
        // TRANSACTION RETRY HELPER (FIX 2: WALLET LATENCY)
        // =================================================================
        async function sendTxWithRetry(provider, txParams, maxAttempts = 3, delay = 500) {
            for (let i = 0; i < maxAttempts; i++) {
                try {
                    if (i > 0) {
                        console.log(`[Blockchain] Retrying transaction... Attempt ${i + 1}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                    
                    const txHash = await provider.request({
                        method: 'eth_sendTransaction',
                        params: txParams
                    });
                    
                    return txHash; // Success! Return hash.

                } catch (error) {
                    // Only retry on communication/timeout errors, otherwise assume contract revert/user rejection
                    const isRetryable = error.message.includes('timeout') || error.message.includes('Queue is full') || error.message.includes('JSON RPC');

                    if (!isRetryable || i === maxAttempts - 1) {
                        console.error('[Blockchain] Transaction failed permanently or non-retryable error:', error.message);
                        // Using console.log instead of alert (prevents sandboxed modal error)
                        console.log(`Transaction failed: ${error.message}`); 
                        throw error;
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // 1. Initialize Farcaster SDK before anything else
            await initSDK(); 

            // =============================================================
            // UI STATE (Non-blockchain)
            // =============================================================
            
            const state = {
                ui: {
                    isDarkMode: false,
                    isSfxMuted: false
                }
            };

            // =============================================================
            // DOM ELEMENTS (remains the same)
            // =============================================================
            const dom = {
                glazery: {
                    kingStatus: document.getElementById('bakery-king-status'),
                    cps: document.getElementById('bakery-cps'),
                    baked: document.getElementById('bakery-baked'),
                    actionButton: document.getElementById('bakery-action-button'),
                    canvas: document.getElementById('cookie-canvas'),
                    rainContainer: document.getElementById('cookie-rain-container'),
                    glazeColorButton: document.getElementById('glaze-color-button'),
                    sprinkleColorButton: document.getElementById('sprinkle-color-button'),
                    donutBaseColorButton: document.getElementById('donut-base-color-button'),
                    zoomSlider: document.getElementById('glazery-zoom-slider'),
                    donutBalance: document.getElementById('player-donut-balance'),
                    glazePrice: document.getElementById('glaze-price-display'),
                    availableBalance: document.getElementById('available-balance-display'),
                    totalSupply: document.getElementById('total-supply-display'),
                    currentDps: document.getElementById('current-dps-display'),
                },
                profileName: document.getElementById('player-profile-name'),
                musicToggleButton: document.getElementById('music-toggle-button'),
                sfxToggleButton: document.getElementById('sfx-toggle-button'),
                darkModeToggleButton: document.getElementById('dark-mode-toggle-button'),
                infoButton: document.getElementById('info-button'),
                infoModal: document.getElementById('info-modal'),
                infoModalOverlay: document.getElementById('info-modal-overlay'),
                infoModalClose: document.getElementById('info-modal-close'),
                modalInfo: {
                    totalSupply: document.getElementById('modal-total-supply'),
                    nextHalving: document.getElementById('modal-next-halving'),
                    currentMiner: document.getElementById('modal-current-miner'),
                }
            };

            // =============================================================
            // HELPER FUNCTIONS (remains the same)
            // =============================================================

            const formatNumber = (num) => {
                const n = parseFloat(num);
                if (n >= 1000000) return (n / 1000000).toFixed(2) + 'M';
                if (n >= 1000) return (n / 1000).toFixed(2) + 'K';
                return n.toFixed(2);
            };
            
            const formatTime = (seconds) => {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = seconds % 60;
                return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            // =============================================================
            // BLOCKCHAIN FUNCTIONS
            // =============================================================
            
            async function getUserAddress() {
                try {
                    console.log('[Blockchain] Getting user address...');
                    
                    if (!FarcasterSDK) throw new Error("SDK not initialized.");
                    
                    // Get FID from Farcaster context
                    const context = await FarcasterSDK.context;
                    if (context && context.user) {
                        blockchainData.fid = context.user.fid;
                        console.log('[Blockchain] FID:', blockchainData.fid);
                    }
                    
                    const provider = await FarcasterSDK.wallet.getEthereumProvider();
                    if (provider) {
                        const accounts = await provider.request({ method: 'eth_requestAccounts' });
                        const address = accounts[0];
                        console.log('[Blockchain] User address:', address);
                        blockchainData.userAddress = address;
                        
                        // Display shortened address
                        if (dom.profileName) {
                            dom.profileName.textContent = `${address.slice(0, 6)}...${address.slice(-4)}`;
                        }
                        
                        return address;
                    }
                } catch (error) {
                    console.log('[Blockchain] Could not get address:', error.message);
                }
                
                if (dom.profileName) {
                    dom.profileName.textContent = 'Not Connected';
                }
                return null;
            }

            async function fetchGameState(userAddress = null) {
                try {
                    const url = userAddress 
                        ? `${API_BASE_URL}/api/get-game-state?userAddress=${userAddress}`
                        : `${API_BASE_URL}/api/get-game-state`;
                    
                    console.log('[Blockchain] Fetching:', url);
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        mode: 'cors'
                    });
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    console.log('[Blockchain] Data received:', data);
                    
                    blockchainData = { ...blockchainData, ...data };
                    updateUI();
                    return data;
                } catch (error) {
                    console.error('[Blockchain] Fetch error:', error);
                    return null;
                }
            }

            async function openGlazeFrame() {
                console.log('[Blockchain] Starting transaction...');
                donutSpinSpeed = 0.5;
                playSoundEffect('purchase');
                
                try {
                    if (!FarcasterSDK) throw new Error("SDK not initialized.");
                    
                    console.log('[Blockchain] Fetching transaction data...');
                    
                    const address = blockchainData.userAddress; // User's wallet address
                    
                    if (!address) {
                        console.log('Transaction failed: Please connect your wallet first'); // FIX 6
                        return;
                    }
                    
                    // 1. Fetch transaction data from your API
                    const txDataResponse = await fetch(`${API_BASE_URL}/api/transaction?player=${address}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        mode: 'cors'
                    });
                    
                    if (!txDataResponse.ok) {
                        const errorText = await txDataResponse.text();
                        console.error('[Blockchain] Transaction API error:', errorText);
                        throw new Error(`Failed to get transaction data: ${txDataResponse.status}`);
                    }
                    
                    const txData = await txDataResponse.json();
                    console.log('[Blockchain] Transaction data received:', txData);
                    
                    const provider = await FarcasterSDK.wallet.getEthereumProvider();
                    
                    if (!provider) {
                        throw new Error('Wallet provider not available');
                    }
                    
                    console.log('[Blockchain] Sending transaction...');
                    
                    const txParams = [{
                        from: address, // Ensure the 'from' address is always set
                        to: txData.params.to,
                        data: txData.params.data,
                        value: txData.params.value, 
                    }];

                    // 2. Use retry function for reliability (FIX 2)
                    const txHash = await sendTxWithRetry(provider, txParams);
                    
                    console.log('[Blockchain] Transaction sent:', txHash);
                    
                    // alert replaced with console.log (FIX 6)
                    console.log('Transaction submitted! Refreshing game state...'); 
                    
                    setTimeout(() => {
                        console.log('[Blockchain] Refreshing after transaction...');
                        fetchGameState(blockchainData.userAddress);
                    }, 3000);
                    
                } catch (error) {
                    console.error('[Blockchain] Transaction error:', error);
                    // alert replaced with console.log (FIX 6)
                    console.log(`Transaction failed: ${error.message}`); 
                }
            }
            
            function handleGlazeClick() {
                console.log('[Blockchain] Glaze button clicked');
                
                // *** REMOVED THE USER IS MINER CHECK (FIX 5) ***
                
                // Play a sound effect to acknowledge the click
                playSoundEffect('purchase'); 
                
                // Always open the glaze frame to initiate a transaction
                openGlazeFrame();
            }

            function updateUI() {
                console.log('[Blockchain] Updating UI');
                
                // Check if user is miner
                const userIsMiner = blockchainData.userAddress && 
                                   blockchainData.currentMiner && 
                                   blockchainData.userAddress.toLowerCase() === blockchainData.currentMiner.toLowerCase();
                
                // --- KING GLAZER DISPLAY FIX (FIX 3) ---
                let kingGlazerDisplay;

                if (userIsMiner) {
                    kingGlazerDisplay = 'You';
                } else if (blockchainData.currentMiner && blockchainData.currentMiner !== '0x0000000000000000000000000000000000000000') {
                    // Display shortened address if it's a valid, non-zero address
                    const address = blockchainData.currentMiner;
                    kingGlazerDisplay = `${address.slice(0, 6)}...${address.slice(-4)}`;
                } else {
                    kingGlazerDisplay = 'None';
                }
                dom.glazery.kingStatus.textContent = kingGlazerDisplay;
                // --- END FIX 3 ---

                dom.glazery.cps.textContent = blockchainData.claimableDonutsFormatted ? formatNumber(blockchainData.claimableDonutsFormatted) : '0.00';
                dom.glazery.baked.textContent = formatTime(blockchainData.timeAsMiner || 0);
                
                // Glaze Price display (FIXED PRECISION)
                dom.glazery.glazePrice.textContent = `${parseFloat(blockchainData.priceInEth || 0).toFixed(6)} ETH`;
                
                // Available Balance display (FIXED PRECISION & UNIT - FIX 4)
                dom.glazery.availableBalance.textContent = `${parseFloat(blockchainData.userEthBalanceFormatted || 0).toFixed(4)} ETH available`;

                dom.glazery.donutBalance.textContent = `🍩 ${formatNumber(blockchainData.userDonutBalanceFormatted || 0)}`;
                dom.glazery.totalSupply.textContent = `🍩 ${formatNumber(blockchainData.totalDonutSupplyFormatted || 0)}`;
                dom.glazery.currentDps.textContent = formatNumber(blockchainData.currentDpsFormatted || 0);
                
                // Update button: Always set to Glaze (FIX 5)
                dom.glazery.actionButton.textContent = 'Glaze';
                
                // Update modal
                if (dom.modalInfo.totalSupply) {
                    dom.modalInfo.totalSupply.textContent = `🍩 ${formatNumber(blockchainData.totalDonutSupplyFormatted || 0)}`;
                    dom.modalInfo.nextHalving.textContent = formatTime(blockchainData.secondsUntilHalving || 0);
                    
                    const minerDisplay = blockchainData.currentMiner 
                        ? `${blockchainData.currentMiner.slice(0, 6)}...${blockchainData.currentMiner.slice(-4)}`
                        : 'None';
                    dom.modalInfo.currentMiner.textContent = minerDisplay;
                }
            }


            // =============================================================
            // AUDIO SETUP (Tone.js) - KEEPING ORIGINAL
            // =============================================================
            let kick, hiHat, bass, melody;
            let kickSequence, hiHatSequence, bassSequence, melodySequence;
            let isMusicPlaying = false;
            let isAudioInitialized = false;
            let purchaseSound, cuteClickSound;

            function initAudio() {
                if (isAudioInitialized) return;

                Tone.Transport.bpm.value = 140;
                Tone.Transport.swing = 0.2;
                Tone.Transport.swingSubdivision = '8n';
                const limiter = new Tone.Limiter(-6).toDestination();

                kick = new Tone.MembraneSynth({
                    pitchDecay: 0.01,
                    octaves: 6,
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.001, decay: 0.3, sustain: 0.01, release: 0.2 }
                }).connect(limiter);
                
                const kickPattern = ['C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null];
                
                kickSequence = new Tone.Sequence((time, note) => {
                    if (note) kick.triggerAttackRelease(note, '8n', time);
                }, kickPattern, '8n');
                kickSequence.loop = true;

                hiHat = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
                }).connect(limiter);

                const hiHatPattern = [null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'GC5', null];

                hiHatSequence = new Tone.Sequence((time, note) => {
                    if (note) hiHat.triggerAttackRelease('8n', time);
                }, hiHatPattern, '8n');
                hiHatSequence.loop = true;

                bass = new Tone.MonoSynth({
                    oscillator: { type: 'sawtooth' },
                    filter: { Q: 2, type: 'lowpass', cutoff: 400 },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.5 }
                }).connect(limiter);

                const bassPattern = ['C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', 'D2'];

                bassSequence = new Tone.Sequence((time, note) => {
                    if (note) bass.triggerAttackRelease(note, '8n', time);
                }, bassPattern, '8n');
                bassSequence.loop = true;

                melody = new Tone.FMSynth({
                    harmonicity: 3,
                    modulationIndex: 10,
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }
                }).connect(limiter);

                const melodyPattern = ['G4', 'A#4', 'C5', null, 'G4', 'D#4', null, null, 'G4', 'A#4', 'C5', null, 'D#5', 'C5', 'A#4', null, 'G4', 'A#4', 'C5', null, 'G4', 'D#4', null, null, 'G4', 'A#4', 'G4', 'D#4', 'C4', null, null, null, 'G#4', 'C5', 'D#5', null, 'C5', 'G#4', null, null, 'G#4', 'C5', 'D#5', null, 'F5', 'D#5', 'C5', null, 'G#4', 'C5', 'D#5', null, 'C5', 'G#4', null, null, 'C5', 'A#4', 'G#4', 'F4', 'D#4', null, null, null, 'F4', 'G#4', 'C5', null, 'G#4', 'F4', null, null, 'F4', 'G#4', 'C5', null, 'D#5', 'C5', 'G#4', null, 'F4', 'G#4', 'C5', null, 'G#4', 'F4', null, null, 'F4', 'G#4', 'F4', 'D#4', 'C4', null, null, null, 'G4', 'B4', 'D5', null, 'D5', 'B4', 'G4', null, 'G4', 'B4', 'D5', 'F5', 'D5', 'B4', 'G4', null, 'A#4', null, 'B4', null, 'C5', null, 'B4', 'A#4', 'G4', 'F4', 'D#4', 'D4', 'C4', null, null, null];
                
                melodySequence = new Tone.Sequence((time, note) => {
                    if (note) melody.triggerAttackRelease(note, '8n', time);
                }, melodyPattern, '8n');
                melodySequence.loop = true;

                cuteClickSound = new Tone.FMSynth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 },
                    harmonicity: 0.5,
                    modulationIndex: 2
                }).connect(limiter);
                
                purchaseSound = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
                }).connect(limiter);

                isAudioInitialized = true;
            }

            function playSoundEffect(sound) {
                if (state.ui.isSfxMuted) return;

                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
                
                if (!isAudioInitialized) {
                    initAudio();
                }
                
                if (sound === 'crunch') {
                    cuteClickSound.triggerAttackRelease('C6', '32n', Tone.now());
                }
                if (sound === 'purchase') {
                    purchaseSound.triggerAttackRelease('C5', '16n', Tone.now());
                    purchaseSound.triggerAttackRelease('E5', '16n', Tone.now() + 0.05);
                    purchaseSound.triggerAttackRelease('G5', '16n', Tone.now() + 0.1);
                }
            }
            
            function toggleSfx() {
                state.ui.isSfxMuted = !state.ui.isSfxMuted;
                dom.sfxToggleButton.textContent = state.ui.isSfxMuted ? '🔇' : '🔊';
                if (!state.ui.isSfxMuted) {
                    playSoundEffect('crunch');
                }
            }

            function toggleMusic() {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }

                if (!isAudioInitialized) {
                    initAudio();
                }

                if (isMusicPlaying) {
                    Tone.Transport.stop();
                    dom.musicToggleButton.textContent = '🔇';
                } else {
                    Tone.Transport.start();
                    if (kickSequence && kickSequence.state === 'stopped') kickSequence.start(0);
                    if (hiHatSequence && hiHatSequence.state === 'stopped') hiHatSequence.start(0);
                    if (bassSequence && bassSequence.state === 'stopped') bassSequence.start(0);
                    if (melodySequence && melodySequence.state === 'stopped') melodySequence.start(0);
                    dom.musicToggleButton.textContent = '🎵';
                }
                isMusicPlaying = !isMusicPlaying;
            }

            // =============================================================
            // DARK MODE TOGGLE
            // =============================================================
            function toggleDarkMode() {
                state.ui.isDarkMode = !state.ui.isDarkMode;
                const body = document.body;
                if (state.ui.isDarkMode) {
                    body.classList.add('dark');
                    dom.darkModeToggleButton.textContent = '☀️';
                } else {
                    body.classList.remove('dark');
                    dom.darkModeToggleButton.textContent = '🌙';
                }
            }

            // =============================================================
            // INFO MODAL
            // =============================================================
            function showInfoModal() {
                playSoundEffect('crunch');
                dom.infoModal.classList.remove('hidden');
                dom.infoModalOverlay.classList.remove('hidden');
            }

            function hideInfoModal() {
                dom.infoModal.classList.add('hidden');
                dom.infoModalOverlay.classList.add('hidden');
            }

            // =============================================================
            // 3D GLAZERY SETUP - KEEPING ALL ORIGINAL CODE
            // =============================================================

            let scene, camera, renderer, donutGroup, glazeMaterial, donutMaterial, sprinkleMeshes = [];
            let isDragging = false;
            let previousPointerX = 0;
            let previousPointerY = 0;
            let initialPinchDistance = 0;
            let currentCameraZ = 10;
            let isThreeJSInitialized = false; 
            let donutSpinSpeed = 0.005;

            const MIN_ZOOM_Z = 3;
            const MAX_ZOOM_Z = 20;

            const glazeColors = [
                0xFFC0CB, 0xADD8E6, 0x90EE90, 0xFFD700,
                0x800080, 0xFFF8DC, 0xFF0000, 0x000000
            ];
            let currentGlazeColorIndex = 0;

            const donutBaseColors = [
                0x5C3317, 0xDEB887, 0x3D2B1F, 0xF5DEB3, 0xFFC0CB, null
            ];
            let currentDonutBaseColorIndex = 0;

            const sprinkleColorSets = [
                [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3],
                [0xFFFFFF, 0xF0F0F0, 0xE0E0E0],
                [0x000000, 0x333333, 0x666666],
                [0xFFC0CB, 0xFF9AA2, 0xFFDDE1],
                [0x87CEEB, 0xADD8E6, 0xB0E0E6],
                [0xDAA520, 0xB8860B, 0xFFD700]
            ];
            let currentSprinkleColorSetIndex = 0;

            function createCrackTexture(size = 1024) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, size, size);

                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                for (let i = 0; i < 15; i++) {
                    ctx.beginPath();
                    let startX = Math.random() * size;
                    let startY = Math.random() * size;
                    ctx.moveTo(startX, startY);
                    let len = Math.random() * 60 + 30;
                    let currentX = startX;
                    let currentY = startY;
                    for (let j = 0; j < 5; j++) {
                         currentX += (Math.random() - 0.5) * len;
                         currentY += (Math.random() - 0.5) * len;
                         currentX = Math.max(0, Math.min(size, currentX));
                         currentY = Math.max(0, Math.min(size, currentY));
                        ctx.lineTo(currentX, currentY);
                        len *= 0.8;
                    }
                    ctx.stroke();
                }

                return new THREE.CanvasTexture(canvas);
            }

            function createSpeckleTexture(size = 512) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF'; 
                ctx.fillRect(0, 0, size, size);

                for (let i = 0; i < 2000; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const r = Math.random() * 0.8 + 0.4;
                    const alpha = Math.random() * 0.5 + 0.3;
                    const shade = Math.floor(Math.random() * 40);
                    ctx.fillStyle = `rgba(${shade}, ${shade}, ${shade}, ${alpha})`; 
                    
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                return new THREE.CanvasTexture(canvas);
            }

            function initThreeJS() {
                if (isThreeJSInitialized) return; 
                
                scene = new THREE.Scene();
                
                const container = dom.glazery.rainContainer;
                if (!container) return;
                const w = container.clientWidth || 300;
                const h = container.clientHeight || 300;

                camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
                camera.position.z = currentCameraZ;

                if (!dom.glazery.canvas) return;
                renderer = new THREE.WebGLRenderer({ 
                    canvas: dom.glazery.canvas,
                    alpha: true
                });
                renderer.setSize(w, h);
                renderer.setPixelRatio(window.devicePixelRatio);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); 
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                donutGroup = new THREE.Group();
                
                const donutGeometry = new THREE.TorusGeometry(2.8, 1.3, 32, 100);

                const crackTexture = createCrackTexture(1024);
                crackTexture.wrapS = crackTexture.wrapT = THREE.RepeatWrapping;
                crackTexture.repeat.set(1, 1);
                
                const speckleTexture = createSpeckleTexture(512);
                speckleTexture.wrapS = speckleTexture.wrapT = THREE.RepeatWrapping;
                speckleTexture.repeat.set(3, 3);

                donutMaterial = new THREE.MeshStandardMaterial({
                    color: donutBaseColors[currentDonutBaseColorIndex],
                    roughness: 0.8,
                    metalness: 0.05,
                    map: speckleTexture,
                    bumpMap: crackTexture,
                    bumpScale: 0.08
                });
                const donutBase = new THREE.Mesh(donutGeometry, donutMaterial);
                donutGroup.add(donutBase);

                const glazeRadius = 2.75; 
                const glazeTubeRadius = 1.35; 
                const radialSegments = 32; 
                const tubularSegments = 100;

                const glazeGeometry = new THREE.TorusGeometry(
                    glazeRadius,
                    glazeTubeRadius,
                    radialSegments,
                    tubularSegments
                );
                
                const positionAttribute = glazeGeometry.attributes.position;
                const tempVector = new THREE.Vector3();
                const irregularityFactor = 0.15; 
                const randomOffsets = new Array(tubularSegments).fill(0).map(() => Math.random() * irregularityFactor * 2 - irregularityFactor);

                for (let i = 0; i < positionAttribute.count; i++) {
                    tempVector.fromBufferAttribute(positionAttribute, i);

                    const x = tempVector.x;
                    const y = tempVector.y;
                    const z = tempVector.z;
                    const r = Math.sqrt(x * x + y * y);
                    const angleAroundDonut = Math.atan2(y, x); 
                    const distFromGlazeMainRadius = Math.abs(r - glazeRadius);
                    const isOuterEdge = distFromGlazeMainRadius < (glazeTubeRadius * 0.4) && r > glazeRadius; 
                    const isBottomHalf = z < -0.4 * glazeTubeRadius; 
                    const isInnerEdge = distFromGlazeMainRadius < (glazeTubeRadius * 0.4) && r < glazeRadius;

                    if (isOuterEdge && isBottomHalf) {
                        const segmentIndex = Math.floor((angleAroundDonut / (2 * Math.PI)) * tubularSegments + tubularSegments) % tubularSegments;
                        const scallopMagnitude = 0.1 + (randomOffsets[segmentIndex] * 0.8 + 0.5) * 0.1; 
                        const currentRadius = Math.sqrt(tempVector.x * tempVector.x + tempVector.y * tempVector.y);
                        const normalizedX = tempVector.x / currentRadius;
                        const normalizedY = tempVector.y / currentRadius;

                        tempVector.x += normalizedX * scallopMagnitude;
                        tempVector.y += normalizedY * scallopMagnitude;
                        tempVector.z += scallopMagnitude * 0.5; 
                        positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
                    } else if (isInnerEdge) {
                        if (tempVector.z < -0.1) { 
                           tempVector.z = Math.min(tempVector.z + 0.1, 0); 
                        }
                        positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
                    }
                }
                glazeGeometry.attributes.position.needsUpdate = true;
                glazeGeometry.computeVertexNormals(); 

                glazeMaterial = new THREE.MeshStandardMaterial({
                    color: glazeColors[currentGlazeColorIndex],
                    roughness: 0.2,  
                    metalness: 0.1,  
                    transparent: true,
                    opacity: 0.85    
                });
                const glaze = new THREE.Mesh(glazeGeometry, glazeMaterial);
                glaze.position.z = 0.05; 
                donutGroup.add(glaze);

                createSprinkles();
                
                scene.add(donutGroup);

                dom.glazery.canvas.addEventListener('pointerdown', onPointerDown);
                dom.glazery.canvas.addEventListener('pointermove', onPointerMove);
                dom.glazery.canvas.addEventListener('pointerup', onPointerUp);
                dom.glazery.canvas.addEventListener('pointerleave', onPointerUp);
                dom.glazery.canvas.addEventListener('wheel', onMouseWheel, { passive: false });
                
                dom.glazery.zoomSlider.min = MIN_ZOOM_Z;
                dom.glazery.zoomSlider.max = MAX_ZOOM_Z;
                dom.glazery.zoomSlider.value = currentCameraZ;
                dom.glazery.zoomSlider.step = 0.1;

                isThreeJSInitialized = true; 
            }

            function createSprinkles() {
                sprinkleMeshes.forEach(sprinkle => donutGroup.remove(sprinkle));
                sprinkleMeshes = [];

                const currentColors = sprinkleColorSets[currentSprinkleColorSetIndex];

                const sprinkleShape = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 8); 
                const numSprinkles = 800; 
                const R_sprinkle = 2.8; 
                const r_sprinkle = 1.3 * 0.9; 

                for (let i = 0; i < numSprinkles; i++) {
                    const color = currentColors[Math.floor(Math.random() * currentColors.length)];
                    const sprinkleMaterial = new THREE.MeshStandardMaterial({ color: color });
                    const sprinkle = new THREE.Mesh(sprinkleShape, sprinkleMaterial);
                    const u = Math.random() * 2 * Math.PI; 
                    const v = Math.random() * 2 * Math.PI; 
                    
                    sprinkle.position.x = (R_sprinkle + r_sprinkle * Math.cos(u)) * Math.cos(v);
                    sprinkle.position.y = (R_sprinkle + r_sprinkle * Math.cos(u)) * Math.sin(v);
                    sprinkle.position.z = r_sprinkle * Math.sin(u);

                    if (sprinkle.position.z < -0.2 * 1.3) { 
                        continue; 
                    }

                    const centerOfTubeCrossSection = new THREE.Vector3(R_sprinkle * Math.cos(v), R_sprinkle * Math.sin(v), 0);
                    const normal = new THREE.Vector3().subVectors(sprinkle.position, centerOfTubeCrossSection).normalize();
                    sprinkle.position.addScaledVector(normal, 0.12); 
                    sprinkle.lookAt(new THREE.Vector3().addVectors(sprinkle.position, normal));
                    sprinkle.rotateX(Math.PI / 2); 
                    sprinkle.rotation.z += Math.random() * Math.PI; 
                    donutGroup.add(sprinkle);
                    sprinkleMeshes.push(sprinkle);
                }
            }

            // =============================================================
            // 3D CONTROLS & ANIMATION
            // =============================================================

            function onResize() {
                if (renderer && camera && dom.glazery.rainContainer) {
                    const container = dom.glazery.rainContainer;
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    if (w > 0 && h > 0) {
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                    }
                }
            }
            window.addEventListener('resize', onResize);

            function animate() {
                requestAnimationFrame(animate);
                
                if (donutGroup && renderer) {
                    donutGroup.rotation.y += donutSpinSpeed; 
                    
                    if (donutSpinSpeed > 0.005) {
                        donutSpinSpeed *= 0.95;
                        if (donutSpinSpeed < 0.006) {
                            donutSpinSpeed = 0.005;
                        }
                    }
                    
                    renderer.render(scene, camera);
                }
            }

            let pointers = [];

            function getPinchDistance(e) {
                if (e.touches && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                return 0;
            }

            function onPointerDown(e) {
                pointers.push(e);
                if (pointers.length === 1) {
                    isDragging = true;
                    previousPointerX = e.clientX;
                    previousPointerY = e.clientY;
                }
                dom.glazery.canvas.setPointerCapture(e.pointerId);
            }

            function onPointerMove(e) {
                const index = pointers.findIndex(p => p.pointerId === e.pointerId);
                if (index > -1) {
                    pointers[index] = e;
                }

                if (pointers.length === 2 && initialPinchDistance > 0) {
                    const currentPinchDistance = getPinchDistance(e);
                    if (currentPinchDistance === 0) return;
                    
                    const zoomFactor = initialPinchDistance / currentPinchDistance;
                    let newZ = currentCameraZ * zoomFactor;
                    
                    newZ = Math.max(MIN_ZOOM_Z, Math.min(MAX_ZOOM_Z, newZ));
                    camera.position.z = newZ;
                    camera.updateProjectionMatrix();
                    dom.glazery.zoomSlider.value = newZ;

                    initialPinchDistance = currentPinchDistance;
                    currentCameraZ = newZ;

                }
                if (isDragging && pointers.length === 1) { 
                    const deltaX = e.clientX - previousPointerX;
                    const deltaY = e.clientY - previousPointerY;
                    
                    donutGroup.rotation.y += deltaX * 0.01;
                    donutGroup.rotation.x += deltaY * 0.01;
                    
                    previousPointerX = e.clientX;
                    previousPointerY = e.clientY;
                }
            }

            function onPointerUp(e) {
                pointers = pointers.filter(p => p.pointerId !== e.pointerId);
                dom.glazery.canvas.releasePointerCapture(e.pointerId);

                if (isDragging && pointers.length === 0) {
                    isDragging = false;
                }

                if (pointers.length < 2) {
                    initialPinchDistance = 0;
                }
            }

            function onMouseWheel(e) {
                e.preventDefault();
                let newZ = currentCameraZ + e.deltaY * 0.02;
                newZ = Math.max(MIN_ZOOM_Z, Math.min(MAX_ZOOM_Z, newZ));
                camera.position.z = newZ;
                camera.updateProjectionMatrix();
                dom.glazery.zoomSlider.value = newZ;
                currentCameraZ = newZ;
            }

            function changeGlazeColor() {
                if (glazeMaterial) {
                    currentGlazeColorIndex = (currentGlazeColorIndex + 1) % glazeColors.length;
                    glazeMaterial.color.set(glazeColors[currentGlazeColorIndex]);
                }
            }

            function changeDonutBaseColor() {
                if (donutMaterial) {
                    currentDonutBaseColorIndex = (currentDonutBaseColorIndex + 1) % donutBaseColors.length;
                    const newColorOrMode = donutBaseColors[currentDonutBaseColorIndex];

                    if (newColorOrMode === null) {
                        donutMaterial.wireframe = true;
                        donutMaterial.color.set(0xF5E6C1); 
                    } else {
                        donutMaterial.wireframe = false;
                        donutMaterial.color.set(newColorOrMode);
                    }
                }
            }

            function changeSprinkleColor() {
                currentSprinkleColorSetIndex = (currentSprinkleColorSetIndex + 1) % sprinkleColorSets.length;
                createSprinkles();
            }

            // =============================================================
            // INITIALIZATION
            // =============================================================
            
            dom.glazery.actionButton.onclick = handleGlazeClick;
            dom.musicToggleButton.onclick = toggleMusic;
            dom.sfxToggleButton.onclick = toggleSfx;
            dom.darkModeToggleButton.onclick = () => {
                playSoundEffect('crunch');
                toggleDarkMode();
            };
            dom.glazery.glazeColorButton.onclick = () => {
                playSoundEffect('crunch');
                changeGlazeColor();
            };
            dom.glazery.sprinkleColorButton.onclick = () => {
                playSoundEffect('crunch');
                changeSprinkleColor();
            };
            dom.glazery.donutBaseColorButton.onclick = () => {
                playSoundEffect('crunch');
                changeDonutBaseColor();
            };

            dom.infoButton.onclick = showInfoModal;
            dom.infoModalClose.onclick = hideInfoModal;
            dom.infoModalOverlay.onclick = hideInfoModal;

            dom.glazery.zoomSlider.oninput = () => {
                if (!isThreeJSInitialized) return;
                const newZ = parseFloat(dom.glazery.zoomSlider.value);
                camera.position.z = newZ;
                camera.updateProjectionMatrix();
                currentCameraZ = newZ;
            };

            // Init blockchain
            async function init() {
                console.log('[Init] Starting...');
                
                // Get user address
                const userAddress = await getUserAddress();
                
                // Fetch initial state
                await fetchGameState(userAddress);
                
                // Auto-refresh
                setInterval(() => {
                    console.log('[Init] Auto-refreshing...');
                    fetchGameState(blockchainData.userAddress);
                }, REFRESH_INTERVAL);
                
                console.log('[Init] Complete!');
            }
            
            // Start everything
            setTimeout(initThreeJS, 0);
            animate();
            init();
        });
    </script>
</body>
</html>
